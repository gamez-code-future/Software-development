# Software-development
yazılım yaşam döngü süreçleri makalem
SDLC (Software Development Life Cycle)
Başlamadan önce bu yazıyı kendim okuyormuş gibi yazmaya gayret edeceğim. Ve bende bu serüvene yeni başlamış biri olarak henüz yolun çok başındayım. İlk önce yazılımı anlamaya çalışmak bu yazıdan en iyi şekilde faydalanmamıza yardımcı olacaktır. Yazılımı kendime göre tanımlayacak olursam bu en temel haliyle inşa etmektir. Mühendislik, mimarlık, ekip çalışması, işçilik gerektiren ve depremlere ve zamana direnebilen ve temellerinden güç alan ve bakıma ihtiyaç duyan bir çalışmadır yazılım. Ve aynı zamanda müşteri ihtiyaçlarını da karşılamaya yöneliktir. Teşbihte hata olmaz diyelim ve yazılımın geçmesi gereken süreçlere bakalım.
SDLC ya da anlayacağımız şekilde söylersek “yazılım yaşam döngü süreçleri” bu işin geçmesi gereken yoldur. Esasen dairesel bir yoldur. Ve döngü tamamlanarak başa gelinir. Şimdi ise yazılım yaşam döngü süreç adımlarına bakalım. En temel şekilde bu süreç dört adımdan oluşur. Bunlar; gereksinimler analizi, tasarım, gerçekleştirim, test ve bakımdır.
1.GEREKSİNİMLER ANALİZİ
Yazılım yaşam döngüsü en iyi şekilde gereksinimlerin belirlenmesiyle başlar. Bu adımda müşterilerle iletişim halinde kalarak yazılım ürününün hangi hizmetleri sağlayacağı, sistemin bu hizmetleri sağlamak adına neye ihtiyacı olduğu, ne kadar zaman alacağı ve sistemin bütçesi belirlenmeli, müşteri iyi dinlenerek ve müşteri istekleri analiz edilerek bir plan çıkarılmalı ve bu plan doğrultusunda diğer adımlara başlanmalıdır. 
2.TASARIM
Gereksinimler analizi, bize yazılım ürününün nasıl olacağı ve ne kadar süreceği hakkında fikir verirken tasarım ise yazılım ürününün bu plan dahilinde inşasıdır. Bu adımda sistemin iç yapısı belirlenir. Bu iç yapıya ait modellemeler, diyagramlar çizilir. Dokümanlar hazırlanır. Yazılım ürününün detaylı tanımlanması ortaya çıkar ve sistem şekillenmeye başlar.
3.GERÇEKLEŞTİRİM
Bu adım en doğru tabiriyle şimdiye kadar yaptığımız analizlerin ve tasarımların hayata geçirilmesini kapsar. Yazılım ürününü program diline dönüştürmeye, veri dosyalarını oluşturmaya ve veri tasarımına başlarız. Bu adım sonunda tasarımın somut halini görürüz.
4.TEST VE BAKIM
Son adımda ise yaptığımız tüm analiz, tasarım ve gerçekleştirim aşamalarını test etmeye başlarız. Bu aşamada sistemi kullanıcıya teslim etmeden önce kontrolden geçiririz. Son bir değerlendirme yaparız. Hata bulmak adına sistemi test ederiz. İyice sınamadan kullanıcıya teslim etmek geri dönülemeyecek sorunlara yol açabileceği gibi zaman, para, emek kaybına hatta hazırladığımız ürün bir sağlık kuruluşu içinse can kaybına bile neden olabilir. Bundan dolayı atlanılmayacak bir aşamadır.
Yazılım ürününün gerçekleştirilmesinden, test edilmesinden ve kullanıcıya teslim edilmesinden sonra bakım safhası başlar. Sistemin donanım öğelerinin bakımı, temizlenmesi ve eskimiş parçaların değişimi yapılır. Sistemin yazılım bakımı ise ortaya çıkan hataların düzeltimi, iyileştirilmesi ve güncellenmesi işlemlerini içerir.

YAZILIM YAŞAM DÖNGÜ MODELLERİ
1.ŞELALE MODELİ
Çağlayan ya da geleneksel model olarak da bilinir. Bu modelde sistematik olarak ilerleyerek ve ardışık bir tutumla yazılım geliştirilir. Öncelikle tüm istekler tanımlanır ve sabitlenir. Bu isteklere göre analiz ve tasarım yapılır. Bu istekler sabitlendikten sonra gerçekleştirime başlanır. Geliştirilen yapılar kendi içinde birleştirilir, kabul testleri yapılır ve müşteriye teslim ettikten sonra bakım aşamasına geçilir. 
Bu modelde yazılım ürününün gelişimi doğrusaldır. Tek yönde olacak şekilde ilerlenir ve herhangi bir sorunda önceki aşamalara zarar vermeyecek şekilde çözümler üretilir. Müşteriden her aşamada onay alınarak ilerlenmesi de daha olumlu sonuçlar verir. Bu model diğerlerine göre daha basit, yönetilmesi daha kolay ve istekleri iyi tanımlanmış, kesinleşmiş, fazla zaman almayan ve bütçesi belli projeler için daha uygun bir yöntemdir. 
Büyük projelerde istekler kesin ve sabit olmadığından bu gibi projeler için uygun değildir. Ayrıca tek yönlü ilerlediği için değişime ve gelişime açık bir model de değildir. Müşteri memnuniyetini sağlamak zordur.

2.V MODELİ 
V modeli, yazılım geliştirme sürecine sistematik bir şekilde yaklaşarak şelale modelindeki test aşamalarının ne zaman yapılacağını ön plana çıkaran bir modeldir. V harfi gibi iki koldan oluşur. Sol kol yazılım üretimine odaklanırken, sağ kol test aşamalarına odaklanır. Bu modelde ayrıca testler sırasında karşılaştığımız hataları hangi adıma giderek düzeltebileceğimizi daha net görebiliriz. V modeli, şelale modelinin gelişmiş hali olduğundan anlaşılması kolaydır. Ve yine isteklerin iyi tanımlandığı, belirsizliklerin az olduğu, aşama aşama ilerlenebilecek projelerde daha olumlu sonuçlar verir.

3.PROTOTİPLEME
Bazı yazılım geliştirme süreçlerinde müşteri genelde yazılım ürününden ne beklediğini belirtir. Ancak ayrıntılı istekleri tanımlayamaz. Ayrıca yazılım geliştiricisi de çoğu zaman yazılım başarımından, veriminden emin  olmayabilir. Bunun gibi birçok belirsizliğin olduğu projelerde prototip yani bir örnek yaklaşımı bu sorunu çözebilir. Prototipleme yönteminde geliştirici ve müşteri beraber bir şekilde projenin isteklerini tanımlarlar, üzerinde durulması gereken noktaları belirlerler. Ve hemen bir tasarım yapılır. Tasarım daha çok müşteri ile olan etkileşimi ya da sistemin en temel işlevlerini belirlemeye yöneliktir. Prototip buna göre yapılır ve müşteri kullanımına sunulur. Bu denemeden sonra istekler yeniden gözden geçirilir. Geliştirici bu istekleri prototipe yansıtır. Bu yöntem birçok araştırma projesinde kullanılır. Ancak istek tanımlamasının eksikliği ve buna bağlı olarak birçok belirsizliğin olması aşamaya önem veren ve sabitlenmiş projeler için elverişsiz bir yöntemdir.

4.SPİRAL MODEL
Spiral model hem şelale modelinin hem de prototiplemenin en iyi yönlerinin birleştirilmesiyle oluşturulmuştur. Spiral model, art arda tekrarlanan dört adımdan meydana gelir. Bunlar isteklerin belirlendiği, kısıtlamaların değerlendirildiği planlama aşaması, risklerin tanımlandığı ve bu risklere olası çözümler getiren risk çözümleme aşaması, yazılım ürününün geliştirildiği geliştirme aşaması ve geliştirilen ürünün müşteri ile beraber incelendiği değerlendirme aşaması. Bu aşamalar gittikçe büyür ve bir spiral halini alır. Bu model risk çözümlemesine önem verir. Ve aynı adımlara tekrar tekrar dönülmesini vurgular. Spiral model, sistemi küçük parçalara böldüğünden en riskli kısımlar görülebilir ve bu kısımlar en önce gerçekleştirilebilir. Hatalar erkenden giderilebilir. Müşteri sistemi daha erken görebilir. Diğer yandan karmaşık bir yapıdır. Küçük parçalar için bile planlama gerekebilir. Maliyetli olabilir. Ve tabi ki büyük projeler için çok daha uygundur.

5.EVRİMSEL GELİŞTİRME MODELİ
Evrimsel geliştirme modeli evrimler halinde yazılım ürünü oluşturmayı hedefler. Her evrimde geliştirilen ürünler uygulama alanında tam bir işlevselliğe sahiptir. Her evrimde geliştirilen ürün teslim edilerek kullanıma sunulur. Ürünün kullanımı sırasında müşteriden gelen dönütler ve geri beslemeler ve yeni gereksinimlerle sonraki evrime geçilir. Her yeni evrim sistemin kapsamını, işlevlerini ve yapısını daha da arttırır. Bu model müşterinin ihtiyaçlarını daha iyi görmesini sağlar. Sürekli bir değerlendirme imkanı sunan bu model karşılaşılabilir riskleri azaltır. Ve buna bağlı olarak hataları da azaltır. Olumsuz taraflarına değinecek olursak tam bir ürün görme olanağı yoktur. Sürekli değişiklik yapmak yazılım ürününün yapısına zarar verebilir. Ve bundan dolayı bakımı zordur. 
Benzer bir model olan evrimsel prototipleme modelinde ise, evrimsel geliştirmeden farklı olarak, her üründe yani evrimde ortaya bir prototip yani ön ürün çıkarılır. Prototipin uygulama alanında sınanmasından sonra müşteri geri bildirimleri alınarak bir başka prototip hazırlanır ve tekrar denemeye sunulur. Bu şekilde yazılım ürünü son halini alınca tam kullanıma sunulur. Ve tam anlaşılmamış gereksinimlerle başlar.

6.ARTIMLI GELİŞTİRME MODELİ
Artımlı geliştirme modeli, müşteri isteklerinin tamamı belirli olan bir yazılım ürününün sürümlerinin geliştirilmesi ilkesine dayanmaktadır. Öncelikle en temel isteklere göre çekirdek yapıda olan ilk ürün geliştirilir. Bu ürün asıl sistemin temel işlevlerini yerine getirebilecek durumdadır. Ancak hala bazı işlevleri eksiktir. Sonraki her artımda(sürümde) isteklerin bir kısmı daha geliştirilerek çekirdek ürüne yeni işlevler eklenir. 
Her artım bir öncekinden daha fazla işlevselliğe sahiptir. Bu model müşteri isteklerinin zamana göre dağıtıldığı sistemleri geliştirmek için kullanılır. Bu modelde bir taraftan üretim yapılırken bir taraftan da uygulama alanında çalışılır. En önemli sistem özellikleri daha çok sınanma imkanı bulur. Esas önemli olan da yapılan değişikliklerin göz önünde bulundurulmasıdır. Aynı zamanda deneyimli personel gerektirir. Çünkü gereksinimleri doğru artımlara atamak bazen zor olabilir ve artımların kendi içlerindeki tekrarlarına izin vermez.
Şelale modelinin katı tutumundan ayrılarak sunulan bir diğer model tekrarlamalı modeldir(iteratif model). Bu model artımsal modele benzerdir. Ancak artımsal model ürünün başlangıç sürümlerini daha büyük sürümlere genişletme amacını taşırken tekrarlamalı model her sürümü daha da iyileştirme amacını benimser. 
Tekrarlamalı modellerin önemli bir örneği de akılcı birleştirilmiş süreçtir. Bu süreç esasen yazılım yaşam döngüsündeki geliştirme adımlarını yeniden tanımlayan ve bu adımların yerine getirilmesi için kurallar sağlayan bir yazılım geliştirme sürecidir.
Artımsal ve tekrarlamalı modellerin başka bir örneği de açık kaynak geliştirmedir. Bu metotla günümüz ücretsiz yazılımları geliştirilmektedir. Bir programcı kendi istekleri doğrultusunda bir yazılımın ilk sürümünü geliştirir. Ve bunu ücretsiz bir şekilde paylaşır. Ondan sonra diğer kullanıcılar bu kaynak kodu kendi ihtiyaçları ve istekleri yönünde geliştirmeye ve hatalar varsa düzelterek iyileştirmeye başlar. Her yeni gelişim paylaşılır. Ve sürekli bir değişimle yeni yazılım ürünleri ortaya çıkar. Ve birçok yazılım ürünü bu şekilde paylaşılır, kullanılır ve sürekli değişime açık bir şekilde yenilenir.

ÇEVİK METOTLAR
Çevik metotlar, yazılım sistemlerini etkili ve verimli bir şekilde modellemeye dayalı yöntemlere verilen genel addır. Artımsal prensiple hızlı yazılım gerçekleştirmeyi önerir. Müşterilerle birlikte çalışma, hızlı teslimatla müşteri memnuniyeti sağlama, kendinden örgütlü takımlar kurma, değişiklere uyum sağlama ve yüz yüze iletişim sağladığı avantajlardır. Geleneksel modellere göre daha esnek ve kullanışlıdır. Sürdürülebilir bir yapı vardır. Basittir. Ancak sürekli bir çalışma ve disiplin gerektirir. Bu metotlar eğer ki projenin yazılım adımında müşteriden gelebilecek istekler tahmin edilemiyorsa ve projenin hemen geliştirilip tasarlanması ve öncesinde ne yapılması gerektiği bilinmiyorsa tercih edilebilir. 
Çevik metotlar, yazılım dünyasında yeni bir akım olarak görülür. Ve birçok metodolojiyi barındırır. En popüler metodolojiler şunlardır;
1.Extreme Programming (XP): Uç programlama olarak da bilinen XP, gelişen müşteri gereksinimlerine yanıt vermeyi ve kaliteyi arttırmayı amaçlayan bir yazılım geliştirme metodudur. Geliştirici ve müşterinin ortak çalışması doğrultusunda yürütülür. Sürekli yenilenmeye dayanır. Sürümler her adımda güncellenir.
2.Feature Driven Development (FDD): Özellik odaklı geliştirme tek bir yaklaşımla çalışır. Genel bir model geliştirin, özelliklerini listeleyin, bu özelliklere göre planlayın, tasarlayın, geliştirin ve en sonunda oluşturun.
3.Adaptive System Development (ASD): Uyarlamalı sistem geliştirme projelerin devamlı bir uyum süreci halinde olması gerektiği fikrini benimser. ASD ile çalışacaksanız; düşünün, açıklayın, iş birliği yapın ve öğrenin.
4.Dynamic Systems Development Method (DSDM): Dinamik sistem geliştirme metodu bir proje yönetimi yaklaşımıdır. Bütçe harcama, teslim tarihleri ve kullanıcı katılımı eksikliği gibi projelerin yaygın problemlerini ele alır. DSDM; iş gereksinimlerine odaklanmayı, kaliteyi korumayı ve arttırmayı, zamanında teslim etmeyi, iş birliği yapmayı, sağlam adımlarla ilerlemeyi, yinelemeli olarak geliştirmeyi, sürekli ve açık bir şekilde iletişim kurmayı benimser.
5.Lean Software Development (LSD): Yalın yazılım geliştirme Toyota tarafından ortaya konulmuş bir yazılım geliştirme yaklaşımıdır. Yedi prensip ile tanımlanabilir; boş harcamaların elenmesi, kalitenin sağlanması, bilgiyi ve öğrenmeyi arttırması, mümkün olduğunca geç kararlar alınması, hızlı dağıtım yapması, ekibi güçlendirmesi ve bütünü en uygun hale getirmesi.
6.Kanban: Çince’de “büyük görsel tahta” anlamına gelen Kanban, Çevik'i uygulamak için görsel bir metottur. Mevcut sisteme küçük ama sürekli değişiklikler sağlar. Kanban’da iş akışını görselleştirin, devam eden çalışmaları sınırlayın, akışı yönetin ve geliştirin, politikaları açık hale getirin ve sürekli iyileştirin.
7.Scrum: Scrum, Çevik’i uygulamak için en popüler metotlardan biridir. Büyük ve karmaşık yazılım süreçlerinin yönetilmesinde tercih edilir. Scrum düzenli geri bildirimlerle, düzenli planlamalar ve düzenli proje kontrolleriyle ilerler. Müşteri ihtiyaçlarıyla şekillenir. Bu ihtiyaçlara yönelik ve esnek bir yapıya sahiptir. Şeffaflık ile projenin ilerleyişi herkes tarafından görülür. Değerlendirilir. Takımlar ve kişiler arası iletişim ve takım çalışmaları çok önemlidir.

SCRUM KAVRAMLARI
1.SCRUM TAKIMI: Fikirleri ürüne dönüştüren kişilerden oluşur.
2.DEVELOPMENT TEAM: Geliştirme işini gerçekleştiren takımdır.
3.SCRUM MASTER: Scrum kurallarını iyi bilen ve Scrum Takımı’nın bu kuralları uygulamasından sorumlu kişidir.
4.PRODUCT OWNER: Ürünün sahibi; fikirleri alır, değerlendirir ve değerli olanları Development Team’e sunar.
5.SPRİNT: Scrum Takımı’nın çalıştığı ürün parçacığının kapsadığı süreyi ifade eder, buna Sprint deriz. Bir Sprint 4 haftadan uzun olamaz.
6.DAİLY SCRUM: Development Team’in 24 saatte bir toplanarak ve dünü, bugünü özetlediği, planlama yaptığı, genel sorunlar üzerinde konuştuğu ve 15 dakika süren toplantılardır.
7.PRODUCT BACKLOG: Bir proje ya da ürün için yapılacak işlerin listesidir.
8.SPRİNT BACKLOG: Sprint planlama toplantısında Development Team üyeleri Sprint Backlog’un içeriğini hazırlarlar. Projeyi nasıl gerçekleştireceklerine dair planlama yaparlar ve Sprint içinde bu şekilde ilerlemeye çalışırlar.
9.SPRİNT REVİEW: Projeye dahil olan tüm kişiler ve Scrum Takımı bu toplantıda bir araya gelir. Scrum Takımı yaptığı işleri anlatır. Bu iş üzerine yapılan yorumları dinler ve geri bildirim alır. Bu geri bildirimler Development Team’in yaptığı işin gelişmesine olanak sağlar. Bu toplantı projenin geleceğine yön verebilir.
10.SPRİNT RETROSPECTİVE: Scrum Takımı için sorun değil ise tüm kişiler katılabilir. Scrum Takımı üyelerinin katılması bir kuraldır. Üyeler kendi aralarındaki iletişimi, yaşadıkları süreçleri değerlendirirler. Bu toplantı Scrum Takımı’nın kendi gelişimine katkı sağlar. Neleri daha iyi yapabiliriz, nasıl daha iyi yapabiliriz soruları üzerinde durulur.
SCRUM’IN POPÜLERLİĞİNE DAİR
Scrum son zamanlarda en çok tercih edilen metotlardan biri olmasıyla belli bir nesnelliğe ulaşmıştır. Ama yine de birkaç öznel fikre başvuracak olursak bu kadar tercih edilmesinin nedenleri şunlardır; şeffaflık ilkesiyle takım içi ve projeye dahil herkes için güven ortamı sağlaması, bundan dolayı odak noktasını projeye yönlendirmesi, deneyimlemenin önünü açması ve en önemlisi Sprint yapılarından dolayı projeyi küçük parçalar halinde kendi içinde spesifik bir şekilde daha yaratıcı ve üretken olarak tamamlamaya çalışması Scrum’ı kompleks yapılı projeler için daha kullanışlı hale getirir. Artık çağ teknoloji çağı olduğundan küçük projeler kimse için yeterli değildir. Herkesin amacı daha iyisi ve daha ilerisi olduğundan Scrum’ın tercih edilmesi kaçınılmaz olur. Diyebiliriz ki bu maratonda Scrum hızını kesmeden ilerlemeye ve en önde gelmeye şu an için devam edecektir. Ancak bu teknoloji yarışında kimse vazgeçilmez değildir. 
Velhasıl buraya kadar birçok yazılım geliştirme modeline ve metodolojisine baktık. Ben bile Scrum’ı en iyisi olarak gördüysem varın gerisini siz düşünün…



